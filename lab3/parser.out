Grammar:

Rule 0     S' -> program
Rule 1     program -> instructions_opt
Rule 2     instructions_opt -> <empty>
Rule 3     instructions_opt -> instructions
Rule 4     instructions -> instruction instructions
Rule 5     instructions -> instruction
Rule 6     instruction -> FOR var = range block
Rule 7     instruction -> WHILE ( condition ) block
Rule 8     instruction -> IF ( condition ) block ELSE block  [precedence=nonassoc, level=2]
Rule 9     instruction -> IF ( condition ) block  [precedence=nonassoc, level=1]
Rule 10    instruction -> statement ;
Rule 11    block -> instructions
Rule 12    block -> { instructions }
Rule 13    range -> num_expr : num_expr
Rule 14    condition -> expr > expr  [precedence=nonassoc, level=3]
Rule 15    condition -> expr < expr  [precedence=nonassoc, level=3]
Rule 16    condition -> expr GREATER_EQUAL expr  [precedence=nonassoc, level=3]
Rule 17    condition -> expr LESS_EQUAL expr  [precedence=nonassoc, level=3]
Rule 18    condition -> expr NOT_EQUAL expr  [precedence=nonassoc, level=3]
Rule 19    condition -> expr EQUAL expr  [precedence=nonassoc, level=3]
Rule 20    assign_op -> =
Rule 21    assign_op -> ADDASSIGN
Rule 22    assign_op -> SUBASSIGN
Rule 23    assign_op -> DIVASSIGN
Rule 24    assign_op -> MULASSIGN
Rule 25    statement -> PRINT print_args
Rule 26    statement -> RETURN expr
Rule 27    statement -> CONTINUE
Rule 28    statement -> BREAK
Rule 29    statement -> element assign_op expr
Rule 30    statement -> var assign_op expr
Rule 31    matrix_function -> matrix_function_name ( INTNUM )
Rule 32    matrix_function_name -> ZEROS
Rule 33    matrix_function_name -> ONES
Rule 34    matrix_function_name -> EYE
Rule 35    matrix -> [ matrix_varargs ]
Rule 36    matrix_varargs -> vector
Rule 37    matrix_varargs -> matrix_varargs , vector
Rule 38    vector -> [ vector_varargs ]
Rule 39    vector_varargs -> INTNUM
Rule 40    vector_varargs -> vector_varargs , INTNUM
Rule 41    element -> matrix_element
Rule 42    element -> vector_element
Rule 43    vector_element -> ID [ INTNUM ]
Rule 44    matrix_element -> ID [ INTNUM , INTNUM ]
Rule 45    var -> ID
Rule 46    expr -> expr '  [precedence=left, level=9]
Rule 47    expr -> - expr  [precedence=right, level=8]
Rule 48    expr -> STRING
Rule 49    expr -> vector_element
Rule 50    expr -> matrix_element
Rule 51    expr -> matrix_function
Rule 52    expr -> matrix
Rule 53    expr -> num_expr
Rule 54    expr -> expr DOTDIV expr  [precedence=left, level=7]
Rule 55    expr -> expr DOTMUL expr  [precedence=left, level=7]
Rule 56    expr -> expr DOTSUB expr  [precedence=left, level=5]
Rule 57    expr -> expr DOTADD expr  [precedence=left, level=5]
Rule 58    expr -> num_expr / num_expr  [precedence=left, level=6]
Rule 59    expr -> num_expr * num_expr  [precedence=left, level=6]
Rule 60    expr -> num_expr - num_expr  [precedence=left, level=4]
Rule 61    expr -> num_expr + num_expr  [precedence=left, level=4]
Rule 62    num_expr -> var
Rule 63    num_expr -> FLOAT
Rule 64    num_expr -> INTNUM
Rule 65    print_args -> expr
Rule 66    print_args -> print_args , expr

Terminals, with rules where they appear:

'                    : 46
(                    : 7 8 9 31
)                    : 7 8 9 31
*                    : 59
+                    : 61
,                    : 37 40 44 66
-                    : 47 60
/                    : 58
:                    : 13
;                    : 10
<                    : 15
=                    : 6 20
>                    : 14
ADDASSIGN            : 21
BREAK                : 28
CONTINUE             : 27
DIVASSIGN            : 23
DOTADD               : 57
DOTDIV               : 54
DOTMUL               : 55
DOTSUB               : 56
ELSE                 : 8
EQUAL                : 19
EYE                  : 34
FLOAT                : 63
FOR                  : 6
GREATER_EQUAL        : 16
ID                   : 43 44 45
IF                   : 8 9
INTNUM               : 31 39 40 43 44 44 64
LESS_EQUAL           : 17
MULASSIGN            : 24
NOT_EQUAL            : 18
ONES                 : 33
PRINT                : 25
RETURN               : 26
STRING               : 48
SUBASSIGN            : 22
WHILE                : 7
ZEROS                : 32
[                    : 35 38 43 44
]                    : 35 38 43 44
error                : 
{                    : 12
}                    : 12

Nonterminals, with rules where they appear:

assign_op            : 29 30
block                : 6 7 8 8 9
condition            : 7 8 9
element              : 29
expr                 : 14 14 15 15 16 16 17 17 18 18 19 19 26 29 30 46 47 54 54 55 55 56 56 57 57 65 66
instruction          : 4 5
instructions         : 3 4 11 12
instructions_opt     : 1
matrix               : 52
matrix_element       : 41 50
matrix_function      : 51
matrix_function_name : 31
matrix_varargs       : 35 37
num_expr             : 13 13 53 58 58 59 59 60 60 61 61
print_args           : 25 66
program              : 0
range                : 6
statement            : 10
var                  : 6 30 62
vector               : 36 37
vector_element       : 42 49
vector_varargs       : 38 40


state 0

    (0) S' -> . program
    (1) program -> . instructions_opt
    (2) instructions_opt -> .
    (3) instructions_opt -> . instructions
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . FOR var = range block
    (7) instruction -> . WHILE ( condition ) block
    (8) instruction -> . IF ( condition ) block ELSE block
    (9) instruction -> . IF ( condition ) block
    (10) instruction -> . statement ;
    (25) statement -> . PRINT print_args
    (26) statement -> . RETURN expr
    (27) statement -> . CONTINUE
    (28) statement -> . BREAK
    (29) statement -> . element assign_op expr
    (30) statement -> . var assign_op expr
    (41) element -> . matrix_element
    (42) element -> . vector_element
    (45) var -> . ID
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (43) vector_element -> . ID [ INTNUM ]
    $end            reduce using rule 2 (instructions_opt -> .)
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 17

    program                        shift and go to state 1
    instructions_opt               shift and go to state 2
    instructions                   shift and go to state 3
    instruction                    shift and go to state 4
    var                            shift and go to state 6
    statement                      shift and go to state 9
    element                        shift and go to state 14
    matrix_element                 shift and go to state 15
    vector_element                 shift and go to state 16

state 1

    (0) S' -> program .


state 2

    (1) program -> instructions_opt .
    $end            reduce using rule 1 (program -> instructions_opt .)


state 3

    (3) instructions_opt -> instructions .
    $end            reduce using rule 3 (instructions_opt -> instructions .)


state 4

    (4) instructions -> instruction . instructions
    (5) instructions -> instruction .
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . FOR var = range block
    (7) instruction -> . WHILE ( condition ) block
    (8) instruction -> . IF ( condition ) block ELSE block
    (9) instruction -> . IF ( condition ) block
    (10) instruction -> . statement ;
    (25) statement -> . PRINT print_args
    (26) statement -> . RETURN expr
    (27) statement -> . CONTINUE
    (28) statement -> . BREAK
    (29) statement -> . element assign_op expr
    (30) statement -> . var assign_op expr
    (41) element -> . matrix_element
    (42) element -> . vector_element
    (45) var -> . ID
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (43) vector_element -> . ID [ INTNUM ]
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    $end            reduce using rule 5 (instructions -> instruction .)
    ELSE            reduce using rule 5 (instructions -> instruction .)
    }               reduce using rule 5 (instructions -> instruction .)
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 17

    instruction                    shift and go to state 4
    instructions                   shift and go to state 18
    var                            shift and go to state 6
    statement                      shift and go to state 9
    element                        shift and go to state 14
    matrix_element                 shift and go to state 15
    vector_element                 shift and go to state 16

state 5

    (6) instruction -> FOR . var = range block
    (45) var -> . ID
    ID              shift and go to state 20

    var                            shift and go to state 19

state 6

    (30) statement -> var . assign_op expr
    (20) assign_op -> . =
    (21) assign_op -> . ADDASSIGN
    (22) assign_op -> . SUBASSIGN
    (23) assign_op -> . DIVASSIGN
    (24) assign_op -> . MULASSIGN
    =               shift and go to state 22
    ADDASSIGN       shift and go to state 23
    SUBASSIGN       shift and go to state 24
    DIVASSIGN       shift and go to state 25
    MULASSIGN       shift and go to state 26

    assign_op                      shift and go to state 21

state 7

    (7) instruction -> WHILE . ( condition ) block
    (               shift and go to state 27


state 8

    (8) instruction -> IF . ( condition ) block ELSE block
    (9) instruction -> IF . ( condition ) block
    (               shift and go to state 28


state 9

    (10) instruction -> statement . ;
    ;               shift and go to state 29


state 10

    (25) statement -> PRINT . print_args
    (65) print_args -> . expr
    (66) print_args -> . print_args , expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    print_args                     shift and go to state 30
    expr                           shift and go to state 31
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 11

    (26) statement -> RETURN . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 48
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 12

    (27) statement -> CONTINUE .
    ;               reduce using rule 27 (statement -> CONTINUE .)


state 13

    (28) statement -> BREAK .
    ;               reduce using rule 28 (statement -> BREAK .)


state 14

    (29) statement -> element . assign_op expr
    (20) assign_op -> . =
    (21) assign_op -> . ADDASSIGN
    (22) assign_op -> . SUBASSIGN
    (23) assign_op -> . DIVASSIGN
    (24) assign_op -> . MULASSIGN
    =               shift and go to state 22
    ADDASSIGN       shift and go to state 23
    SUBASSIGN       shift and go to state 24
    DIVASSIGN       shift and go to state 25
    MULASSIGN       shift and go to state 26

    assign_op                      shift and go to state 49

state 15

    (41) element -> matrix_element .
    =               reduce using rule 41 (element -> matrix_element .)
    ADDASSIGN       reduce using rule 41 (element -> matrix_element .)
    SUBASSIGN       reduce using rule 41 (element -> matrix_element .)
    DIVASSIGN       reduce using rule 41 (element -> matrix_element .)
    MULASSIGN       reduce using rule 41 (element -> matrix_element .)


state 16

    (42) element -> vector_element .
    =               reduce using rule 42 (element -> vector_element .)
    ADDASSIGN       reduce using rule 42 (element -> vector_element .)
    SUBASSIGN       reduce using rule 42 (element -> vector_element .)
    DIVASSIGN       reduce using rule 42 (element -> vector_element .)
    MULASSIGN       reduce using rule 42 (element -> vector_element .)


state 17

    (45) var -> ID .
    (44) matrix_element -> ID . [ INTNUM , INTNUM ]
    (43) vector_element -> ID . [ INTNUM ]
    =               reduce using rule 45 (var -> ID .)
    ADDASSIGN       reduce using rule 45 (var -> ID .)
    SUBASSIGN       reduce using rule 45 (var -> ID .)
    DIVASSIGN       reduce using rule 45 (var -> ID .)
    MULASSIGN       reduce using rule 45 (var -> ID .)
    [               shift and go to state 50


state 18

    (4) instructions -> instruction instructions .
    $end            reduce using rule 4 (instructions -> instruction instructions .)
    FOR             reduce using rule 4 (instructions -> instruction instructions .)
    WHILE           reduce using rule 4 (instructions -> instruction instructions .)
    IF              reduce using rule 4 (instructions -> instruction instructions .)
    PRINT           reduce using rule 4 (instructions -> instruction instructions .)
    RETURN          reduce using rule 4 (instructions -> instruction instructions .)
    CONTINUE        reduce using rule 4 (instructions -> instruction instructions .)
    BREAK           reduce using rule 4 (instructions -> instruction instructions .)
    ID              reduce using rule 4 (instructions -> instruction instructions .)
    ELSE            reduce using rule 4 (instructions -> instruction instructions .)
    }               reduce using rule 4 (instructions -> instruction instructions .)


state 19

    (6) instruction -> FOR var . = range block
    =               shift and go to state 51


state 20

    (45) var -> ID .
    =               reduce using rule 45 (var -> ID .)
    :               reduce using rule 45 (var -> ID .)
    '               reduce using rule 45 (var -> ID .)
    DOTDIV          reduce using rule 45 (var -> ID .)
    DOTMUL          reduce using rule 45 (var -> ID .)
    DOTSUB          reduce using rule 45 (var -> ID .)
    DOTADD          reduce using rule 45 (var -> ID .)
    ,               reduce using rule 45 (var -> ID .)
    ;               reduce using rule 45 (var -> ID .)
    >               reduce using rule 45 (var -> ID .)
    <               reduce using rule 45 (var -> ID .)
    GREATER_EQUAL   reduce using rule 45 (var -> ID .)
    LESS_EQUAL      reduce using rule 45 (var -> ID .)
    NOT_EQUAL       reduce using rule 45 (var -> ID .)
    EQUAL           reduce using rule 45 (var -> ID .)
    )               reduce using rule 45 (var -> ID .)
    {               reduce using rule 45 (var -> ID .)
    FOR             reduce using rule 45 (var -> ID .)
    WHILE           reduce using rule 45 (var -> ID .)
    IF              reduce using rule 45 (var -> ID .)
    PRINT           reduce using rule 45 (var -> ID .)
    RETURN          reduce using rule 45 (var -> ID .)
    CONTINUE        reduce using rule 45 (var -> ID .)
    BREAK           reduce using rule 45 (var -> ID .)
    ID              reduce using rule 45 (var -> ID .)


state 21

    (30) statement -> var assign_op . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    var                            shift and go to state 43
    expr                           shift and go to state 52
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42

state 22

    (20) assign_op -> = .
    -               reduce using rule 20 (assign_op -> = .)
    STRING          reduce using rule 20 (assign_op -> = .)
    ID              reduce using rule 20 (assign_op -> = .)
    [               reduce using rule 20 (assign_op -> = .)
    FLOAT           reduce using rule 20 (assign_op -> = .)
    INTNUM          reduce using rule 20 (assign_op -> = .)
    ZEROS           reduce using rule 20 (assign_op -> = .)
    ONES            reduce using rule 20 (assign_op -> = .)
    EYE             reduce using rule 20 (assign_op -> = .)


state 23

    (21) assign_op -> ADDASSIGN .
    -               reduce using rule 21 (assign_op -> ADDASSIGN .)
    STRING          reduce using rule 21 (assign_op -> ADDASSIGN .)
    ID              reduce using rule 21 (assign_op -> ADDASSIGN .)
    [               reduce using rule 21 (assign_op -> ADDASSIGN .)
    FLOAT           reduce using rule 21 (assign_op -> ADDASSIGN .)
    INTNUM          reduce using rule 21 (assign_op -> ADDASSIGN .)
    ZEROS           reduce using rule 21 (assign_op -> ADDASSIGN .)
    ONES            reduce using rule 21 (assign_op -> ADDASSIGN .)
    EYE             reduce using rule 21 (assign_op -> ADDASSIGN .)


state 24

    (22) assign_op -> SUBASSIGN .
    -               reduce using rule 22 (assign_op -> SUBASSIGN .)
    STRING          reduce using rule 22 (assign_op -> SUBASSIGN .)
    ID              reduce using rule 22 (assign_op -> SUBASSIGN .)
    [               reduce using rule 22 (assign_op -> SUBASSIGN .)
    FLOAT           reduce using rule 22 (assign_op -> SUBASSIGN .)
    INTNUM          reduce using rule 22 (assign_op -> SUBASSIGN .)
    ZEROS           reduce using rule 22 (assign_op -> SUBASSIGN .)
    ONES            reduce using rule 22 (assign_op -> SUBASSIGN .)
    EYE             reduce using rule 22 (assign_op -> SUBASSIGN .)


state 25

    (23) assign_op -> DIVASSIGN .
    -               reduce using rule 23 (assign_op -> DIVASSIGN .)
    STRING          reduce using rule 23 (assign_op -> DIVASSIGN .)
    ID              reduce using rule 23 (assign_op -> DIVASSIGN .)
    [               reduce using rule 23 (assign_op -> DIVASSIGN .)
    FLOAT           reduce using rule 23 (assign_op -> DIVASSIGN .)
    INTNUM          reduce using rule 23 (assign_op -> DIVASSIGN .)
    ZEROS           reduce using rule 23 (assign_op -> DIVASSIGN .)
    ONES            reduce using rule 23 (assign_op -> DIVASSIGN .)
    EYE             reduce using rule 23 (assign_op -> DIVASSIGN .)


state 26

    (24) assign_op -> MULASSIGN .
    -               reduce using rule 24 (assign_op -> MULASSIGN .)
    STRING          reduce using rule 24 (assign_op -> MULASSIGN .)
    ID              reduce using rule 24 (assign_op -> MULASSIGN .)
    [               reduce using rule 24 (assign_op -> MULASSIGN .)
    FLOAT           reduce using rule 24 (assign_op -> MULASSIGN .)
    INTNUM          reduce using rule 24 (assign_op -> MULASSIGN .)
    ZEROS           reduce using rule 24 (assign_op -> MULASSIGN .)
    ONES            reduce using rule 24 (assign_op -> MULASSIGN .)
    EYE             reduce using rule 24 (assign_op -> MULASSIGN .)


state 27

    (7) instruction -> WHILE ( . condition ) block
    (14) condition -> . expr > expr
    (15) condition -> . expr < expr
    (16) condition -> . expr GREATER_EQUAL expr
    (17) condition -> . expr LESS_EQUAL expr
    (18) condition -> . expr NOT_EQUAL expr
    (19) condition -> . expr EQUAL expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    condition                      shift and go to state 53
    expr                           shift and go to state 54
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 28

    (8) instruction -> IF ( . condition ) block ELSE block
    (9) instruction -> IF ( . condition ) block
    (14) condition -> . expr > expr
    (15) condition -> . expr < expr
    (16) condition -> . expr GREATER_EQUAL expr
    (17) condition -> . expr LESS_EQUAL expr
    (18) condition -> . expr NOT_EQUAL expr
    (19) condition -> . expr EQUAL expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    condition                      shift and go to state 55
    expr                           shift and go to state 54
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 29

    (10) instruction -> statement ; .
    FOR             reduce using rule 10 (instruction -> statement ; .)
    WHILE           reduce using rule 10 (instruction -> statement ; .)
    IF              reduce using rule 10 (instruction -> statement ; .)
    PRINT           reduce using rule 10 (instruction -> statement ; .)
    RETURN          reduce using rule 10 (instruction -> statement ; .)
    CONTINUE        reduce using rule 10 (instruction -> statement ; .)
    BREAK           reduce using rule 10 (instruction -> statement ; .)
    ID              reduce using rule 10 (instruction -> statement ; .)
    $end            reduce using rule 10 (instruction -> statement ; .)
    ELSE            reduce using rule 10 (instruction -> statement ; .)
    }               reduce using rule 10 (instruction -> statement ; .)


state 30

    (25) statement -> PRINT print_args .
    (66) print_args -> print_args . , expr
    ;               reduce using rule 25 (statement -> PRINT print_args .)
    ,               shift and go to state 56


state 31

    (65) print_args -> expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    ,               reduce using rule 65 (print_args -> expr .)
    ;               reduce using rule 65 (print_args -> expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 32

    (47) expr -> - . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 62
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 33

    (48) expr -> STRING .
    '               reduce using rule 48 (expr -> STRING .)
    DOTDIV          reduce using rule 48 (expr -> STRING .)
    DOTMUL          reduce using rule 48 (expr -> STRING .)
    DOTSUB          reduce using rule 48 (expr -> STRING .)
    DOTADD          reduce using rule 48 (expr -> STRING .)
    ,               reduce using rule 48 (expr -> STRING .)
    ;               reduce using rule 48 (expr -> STRING .)
    >               reduce using rule 48 (expr -> STRING .)
    <               reduce using rule 48 (expr -> STRING .)
    GREATER_EQUAL   reduce using rule 48 (expr -> STRING .)
    LESS_EQUAL      reduce using rule 48 (expr -> STRING .)
    NOT_EQUAL       reduce using rule 48 (expr -> STRING .)
    EQUAL           reduce using rule 48 (expr -> STRING .)
    )               reduce using rule 48 (expr -> STRING .)


state 34

    (49) expr -> vector_element .
    '               reduce using rule 49 (expr -> vector_element .)
    DOTDIV          reduce using rule 49 (expr -> vector_element .)
    DOTMUL          reduce using rule 49 (expr -> vector_element .)
    DOTSUB          reduce using rule 49 (expr -> vector_element .)
    DOTADD          reduce using rule 49 (expr -> vector_element .)
    ,               reduce using rule 49 (expr -> vector_element .)
    ;               reduce using rule 49 (expr -> vector_element .)
    >               reduce using rule 49 (expr -> vector_element .)
    <               reduce using rule 49 (expr -> vector_element .)
    GREATER_EQUAL   reduce using rule 49 (expr -> vector_element .)
    LESS_EQUAL      reduce using rule 49 (expr -> vector_element .)
    NOT_EQUAL       reduce using rule 49 (expr -> vector_element .)
    EQUAL           reduce using rule 49 (expr -> vector_element .)
    )               reduce using rule 49 (expr -> vector_element .)


state 35

    (50) expr -> matrix_element .
    '               reduce using rule 50 (expr -> matrix_element .)
    DOTDIV          reduce using rule 50 (expr -> matrix_element .)
    DOTMUL          reduce using rule 50 (expr -> matrix_element .)
    DOTSUB          reduce using rule 50 (expr -> matrix_element .)
    DOTADD          reduce using rule 50 (expr -> matrix_element .)
    ,               reduce using rule 50 (expr -> matrix_element .)
    ;               reduce using rule 50 (expr -> matrix_element .)
    >               reduce using rule 50 (expr -> matrix_element .)
    <               reduce using rule 50 (expr -> matrix_element .)
    GREATER_EQUAL   reduce using rule 50 (expr -> matrix_element .)
    LESS_EQUAL      reduce using rule 50 (expr -> matrix_element .)
    NOT_EQUAL       reduce using rule 50 (expr -> matrix_element .)
    EQUAL           reduce using rule 50 (expr -> matrix_element .)
    )               reduce using rule 50 (expr -> matrix_element .)


state 36

    (51) expr -> matrix_function .
    '               reduce using rule 51 (expr -> matrix_function .)
    DOTDIV          reduce using rule 51 (expr -> matrix_function .)
    DOTMUL          reduce using rule 51 (expr -> matrix_function .)
    DOTSUB          reduce using rule 51 (expr -> matrix_function .)
    DOTADD          reduce using rule 51 (expr -> matrix_function .)
    ,               reduce using rule 51 (expr -> matrix_function .)
    ;               reduce using rule 51 (expr -> matrix_function .)
    >               reduce using rule 51 (expr -> matrix_function .)
    <               reduce using rule 51 (expr -> matrix_function .)
    GREATER_EQUAL   reduce using rule 51 (expr -> matrix_function .)
    LESS_EQUAL      reduce using rule 51 (expr -> matrix_function .)
    NOT_EQUAL       reduce using rule 51 (expr -> matrix_function .)
    EQUAL           reduce using rule 51 (expr -> matrix_function .)
    )               reduce using rule 51 (expr -> matrix_function .)


state 37

    (52) expr -> matrix .
    '               reduce using rule 52 (expr -> matrix .)
    DOTDIV          reduce using rule 52 (expr -> matrix .)
    DOTMUL          reduce using rule 52 (expr -> matrix .)
    DOTSUB          reduce using rule 52 (expr -> matrix .)
    DOTADD          reduce using rule 52 (expr -> matrix .)
    ,               reduce using rule 52 (expr -> matrix .)
    ;               reduce using rule 52 (expr -> matrix .)
    >               reduce using rule 52 (expr -> matrix .)
    <               reduce using rule 52 (expr -> matrix .)
    GREATER_EQUAL   reduce using rule 52 (expr -> matrix .)
    LESS_EQUAL      reduce using rule 52 (expr -> matrix .)
    NOT_EQUAL       reduce using rule 52 (expr -> matrix .)
    EQUAL           reduce using rule 52 (expr -> matrix .)
    )               reduce using rule 52 (expr -> matrix .)


state 38

    (53) expr -> num_expr .
    (58) expr -> num_expr . / num_expr
    (59) expr -> num_expr . * num_expr
    (60) expr -> num_expr . - num_expr
    (61) expr -> num_expr . + num_expr
    '               reduce using rule 53 (expr -> num_expr .)
    DOTDIV          reduce using rule 53 (expr -> num_expr .)
    DOTMUL          reduce using rule 53 (expr -> num_expr .)
    DOTSUB          reduce using rule 53 (expr -> num_expr .)
    DOTADD          reduce using rule 53 (expr -> num_expr .)
    ,               reduce using rule 53 (expr -> num_expr .)
    ;               reduce using rule 53 (expr -> num_expr .)
    >               reduce using rule 53 (expr -> num_expr .)
    <               reduce using rule 53 (expr -> num_expr .)
    GREATER_EQUAL   reduce using rule 53 (expr -> num_expr .)
    LESS_EQUAL      reduce using rule 53 (expr -> num_expr .)
    NOT_EQUAL       reduce using rule 53 (expr -> num_expr .)
    EQUAL           reduce using rule 53 (expr -> num_expr .)
    )               reduce using rule 53 (expr -> num_expr .)
    /               shift and go to state 63
    *               shift and go to state 64
    -               shift and go to state 65
    +               shift and go to state 66


state 39

    (43) vector_element -> ID . [ INTNUM ]
    (44) matrix_element -> ID . [ INTNUM , INTNUM ]
    (45) var -> ID .
    [               shift and go to state 67
    /               reduce using rule 45 (var -> ID .)
    *               reduce using rule 45 (var -> ID .)
    -               reduce using rule 45 (var -> ID .)
    +               reduce using rule 45 (var -> ID .)
    '               reduce using rule 45 (var -> ID .)
    DOTDIV          reduce using rule 45 (var -> ID .)
    DOTMUL          reduce using rule 45 (var -> ID .)
    DOTSUB          reduce using rule 45 (var -> ID .)
    DOTADD          reduce using rule 45 (var -> ID .)
    ,               reduce using rule 45 (var -> ID .)
    ;               reduce using rule 45 (var -> ID .)
    >               reduce using rule 45 (var -> ID .)
    <               reduce using rule 45 (var -> ID .)
    GREATER_EQUAL   reduce using rule 45 (var -> ID .)
    LESS_EQUAL      reduce using rule 45 (var -> ID .)
    NOT_EQUAL       reduce using rule 45 (var -> ID .)
    EQUAL           reduce using rule 45 (var -> ID .)
    )               reduce using rule 45 (var -> ID .)


state 40

    (35) matrix -> [ . matrix_varargs ]
    (36) matrix_varargs -> . vector
    (37) matrix_varargs -> . matrix_varargs , vector
    (38) vector -> . [ vector_varargs ]
    [               shift and go to state 68

    matrix_varargs                 shift and go to state 69
    vector                         shift and go to state 70

state 41

    (64) num_expr -> INTNUM .
    /               reduce using rule 64 (num_expr -> INTNUM .)
    *               reduce using rule 64 (num_expr -> INTNUM .)
    -               reduce using rule 64 (num_expr -> INTNUM .)
    +               reduce using rule 64 (num_expr -> INTNUM .)
    '               reduce using rule 64 (num_expr -> INTNUM .)
    DOTDIV          reduce using rule 64 (num_expr -> INTNUM .)
    DOTMUL          reduce using rule 64 (num_expr -> INTNUM .)
    DOTSUB          reduce using rule 64 (num_expr -> INTNUM .)
    DOTADD          reduce using rule 64 (num_expr -> INTNUM .)
    ,               reduce using rule 64 (num_expr -> INTNUM .)
    ;               reduce using rule 64 (num_expr -> INTNUM .)
    >               reduce using rule 64 (num_expr -> INTNUM .)
    <               reduce using rule 64 (num_expr -> INTNUM .)
    GREATER_EQUAL   reduce using rule 64 (num_expr -> INTNUM .)
    LESS_EQUAL      reduce using rule 64 (num_expr -> INTNUM .)
    NOT_EQUAL       reduce using rule 64 (num_expr -> INTNUM .)
    EQUAL           reduce using rule 64 (num_expr -> INTNUM .)
    )               reduce using rule 64 (num_expr -> INTNUM .)
    :               reduce using rule 64 (num_expr -> INTNUM .)
    {               reduce using rule 64 (num_expr -> INTNUM .)
    FOR             reduce using rule 64 (num_expr -> INTNUM .)
    WHILE           reduce using rule 64 (num_expr -> INTNUM .)
    IF              reduce using rule 64 (num_expr -> INTNUM .)
    PRINT           reduce using rule 64 (num_expr -> INTNUM .)
    RETURN          reduce using rule 64 (num_expr -> INTNUM .)
    CONTINUE        reduce using rule 64 (num_expr -> INTNUM .)
    BREAK           reduce using rule 64 (num_expr -> INTNUM .)
    ID              reduce using rule 64 (num_expr -> INTNUM .)


state 42

    (31) matrix_function -> matrix_function_name . ( INTNUM )
    (               shift and go to state 71


state 43

    (62) num_expr -> var .
    /               reduce using rule 62 (num_expr -> var .)
    *               reduce using rule 62 (num_expr -> var .)
    -               reduce using rule 62 (num_expr -> var .)
    +               reduce using rule 62 (num_expr -> var .)
    '               reduce using rule 62 (num_expr -> var .)
    DOTDIV          reduce using rule 62 (num_expr -> var .)
    DOTMUL          reduce using rule 62 (num_expr -> var .)
    DOTSUB          reduce using rule 62 (num_expr -> var .)
    DOTADD          reduce using rule 62 (num_expr -> var .)
    ,               reduce using rule 62 (num_expr -> var .)
    ;               reduce using rule 62 (num_expr -> var .)
    >               reduce using rule 62 (num_expr -> var .)
    <               reduce using rule 62 (num_expr -> var .)
    GREATER_EQUAL   reduce using rule 62 (num_expr -> var .)
    LESS_EQUAL      reduce using rule 62 (num_expr -> var .)
    NOT_EQUAL       reduce using rule 62 (num_expr -> var .)
    EQUAL           reduce using rule 62 (num_expr -> var .)
    )               reduce using rule 62 (num_expr -> var .)
    :               reduce using rule 62 (num_expr -> var .)
    {               reduce using rule 62 (num_expr -> var .)
    FOR             reduce using rule 62 (num_expr -> var .)
    WHILE           reduce using rule 62 (num_expr -> var .)
    IF              reduce using rule 62 (num_expr -> var .)
    PRINT           reduce using rule 62 (num_expr -> var .)
    RETURN          reduce using rule 62 (num_expr -> var .)
    CONTINUE        reduce using rule 62 (num_expr -> var .)
    BREAK           reduce using rule 62 (num_expr -> var .)
    ID              reduce using rule 62 (num_expr -> var .)


state 44

    (63) num_expr -> FLOAT .
    /               reduce using rule 63 (num_expr -> FLOAT .)
    *               reduce using rule 63 (num_expr -> FLOAT .)
    -               reduce using rule 63 (num_expr -> FLOAT .)
    +               reduce using rule 63 (num_expr -> FLOAT .)
    '               reduce using rule 63 (num_expr -> FLOAT .)
    DOTDIV          reduce using rule 63 (num_expr -> FLOAT .)
    DOTMUL          reduce using rule 63 (num_expr -> FLOAT .)
    DOTSUB          reduce using rule 63 (num_expr -> FLOAT .)
    DOTADD          reduce using rule 63 (num_expr -> FLOAT .)
    ,               reduce using rule 63 (num_expr -> FLOAT .)
    ;               reduce using rule 63 (num_expr -> FLOAT .)
    >               reduce using rule 63 (num_expr -> FLOAT .)
    <               reduce using rule 63 (num_expr -> FLOAT .)
    GREATER_EQUAL   reduce using rule 63 (num_expr -> FLOAT .)
    LESS_EQUAL      reduce using rule 63 (num_expr -> FLOAT .)
    NOT_EQUAL       reduce using rule 63 (num_expr -> FLOAT .)
    EQUAL           reduce using rule 63 (num_expr -> FLOAT .)
    )               reduce using rule 63 (num_expr -> FLOAT .)
    :               reduce using rule 63 (num_expr -> FLOAT .)
    {               reduce using rule 63 (num_expr -> FLOAT .)
    FOR             reduce using rule 63 (num_expr -> FLOAT .)
    WHILE           reduce using rule 63 (num_expr -> FLOAT .)
    IF              reduce using rule 63 (num_expr -> FLOAT .)
    PRINT           reduce using rule 63 (num_expr -> FLOAT .)
    RETURN          reduce using rule 63 (num_expr -> FLOAT .)
    CONTINUE        reduce using rule 63 (num_expr -> FLOAT .)
    BREAK           reduce using rule 63 (num_expr -> FLOAT .)
    ID              reduce using rule 63 (num_expr -> FLOAT .)


state 45

    (32) matrix_function_name -> ZEROS .
    (               reduce using rule 32 (matrix_function_name -> ZEROS .)


state 46

    (33) matrix_function_name -> ONES .
    (               reduce using rule 33 (matrix_function_name -> ONES .)


state 47

    (34) matrix_function_name -> EYE .
    (               reduce using rule 34 (matrix_function_name -> EYE .)


state 48

    (26) statement -> RETURN expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    ;               reduce using rule 26 (statement -> RETURN expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 49

    (29) statement -> element assign_op . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 72
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 50

    (44) matrix_element -> ID [ . INTNUM , INTNUM ]
    (43) vector_element -> ID [ . INTNUM ]
    INTNUM          shift and go to state 73


state 51

    (6) instruction -> FOR var = . range block
    (13) range -> . num_expr : num_expr
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (45) var -> . ID
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ID              shift and go to state 20

    var                            shift and go to state 43
    range                          shift and go to state 74
    num_expr                       shift and go to state 75

state 52

    (30) statement -> var assign_op expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    ;               reduce using rule 30 (statement -> var assign_op expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 53

    (7) instruction -> WHILE ( condition . ) block
    )               shift and go to state 76


state 54

    (14) condition -> expr . > expr
    (15) condition -> expr . < expr
    (16) condition -> expr . GREATER_EQUAL expr
    (17) condition -> expr . LESS_EQUAL expr
    (18) condition -> expr . NOT_EQUAL expr
    (19) condition -> expr . EQUAL expr
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    >               shift and go to state 77
    <               shift and go to state 78
    GREATER_EQUAL   shift and go to state 79
    LESS_EQUAL      shift and go to state 80
    NOT_EQUAL       shift and go to state 81
    EQUAL           shift and go to state 82
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 55

    (8) instruction -> IF ( condition . ) block ELSE block
    (9) instruction -> IF ( condition . ) block
    )               shift and go to state 83


state 56

    (66) print_args -> print_args , . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 84
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 57

    (46) expr -> expr ' .
    '               reduce using rule 46 (expr -> expr ' .)
    DOTDIV          reduce using rule 46 (expr -> expr ' .)
    DOTMUL          reduce using rule 46 (expr -> expr ' .)
    DOTSUB          reduce using rule 46 (expr -> expr ' .)
    DOTADD          reduce using rule 46 (expr -> expr ' .)
    ,               reduce using rule 46 (expr -> expr ' .)
    ;               reduce using rule 46 (expr -> expr ' .)
    >               reduce using rule 46 (expr -> expr ' .)
    <               reduce using rule 46 (expr -> expr ' .)
    GREATER_EQUAL   reduce using rule 46 (expr -> expr ' .)
    LESS_EQUAL      reduce using rule 46 (expr -> expr ' .)
    NOT_EQUAL       reduce using rule 46 (expr -> expr ' .)
    EQUAL           reduce using rule 46 (expr -> expr ' .)
    )               reduce using rule 46 (expr -> expr ' .)


state 58

    (54) expr -> expr DOTDIV . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 85
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 59

    (55) expr -> expr DOTMUL . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 86
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 60

    (56) expr -> expr DOTSUB . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 87
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 61

    (57) expr -> expr DOTADD . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 88
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 62

    (47) expr -> - expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    DOTDIV          reduce using rule 47 (expr -> - expr .)
    DOTMUL          reduce using rule 47 (expr -> - expr .)
    DOTSUB          reduce using rule 47 (expr -> - expr .)
    DOTADD          reduce using rule 47 (expr -> - expr .)
    ,               reduce using rule 47 (expr -> - expr .)
    ;               reduce using rule 47 (expr -> - expr .)
    >               reduce using rule 47 (expr -> - expr .)
    <               reduce using rule 47 (expr -> - expr .)
    GREATER_EQUAL   reduce using rule 47 (expr -> - expr .)
    LESS_EQUAL      reduce using rule 47 (expr -> - expr .)
    NOT_EQUAL       reduce using rule 47 (expr -> - expr .)
    EQUAL           reduce using rule 47 (expr -> - expr .)
    )               reduce using rule 47 (expr -> - expr .)
    '               shift and go to state 57


state 63

    (58) expr -> num_expr / . num_expr
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (45) var -> . ID
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ID              shift and go to state 20

    num_expr                       shift and go to state 89
    var                            shift and go to state 43

state 64

    (59) expr -> num_expr * . num_expr
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (45) var -> . ID
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ID              shift and go to state 20

    num_expr                       shift and go to state 90
    var                            shift and go to state 43

state 65

    (60) expr -> num_expr - . num_expr
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (45) var -> . ID
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ID              shift and go to state 20

    num_expr                       shift and go to state 91
    var                            shift and go to state 43

state 66

    (61) expr -> num_expr + . num_expr
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (45) var -> . ID
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ID              shift and go to state 20

    num_expr                       shift and go to state 92
    var                            shift and go to state 43

state 67

    (43) vector_element -> ID [ . INTNUM ]
    (44) matrix_element -> ID [ . INTNUM , INTNUM ]
    INTNUM          shift and go to state 93


state 68

    (38) vector -> [ . vector_varargs ]
    (39) vector_varargs -> . INTNUM
    (40) vector_varargs -> . vector_varargs , INTNUM
    INTNUM          shift and go to state 95

    vector_varargs                 shift and go to state 94

state 69

    (35) matrix -> [ matrix_varargs . ]
    (37) matrix_varargs -> matrix_varargs . , vector
    ]               shift and go to state 96
    ,               shift and go to state 97


state 70

    (36) matrix_varargs -> vector .
    ]               reduce using rule 36 (matrix_varargs -> vector .)
    ,               reduce using rule 36 (matrix_varargs -> vector .)


state 71

    (31) matrix_function -> matrix_function_name ( . INTNUM )
    INTNUM          shift and go to state 98


state 72

    (29) statement -> element assign_op expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    ;               reduce using rule 29 (statement -> element assign_op expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 73

    (44) matrix_element -> ID [ INTNUM . , INTNUM ]
    (43) vector_element -> ID [ INTNUM . ]
    ,               shift and go to state 99
    ]               shift and go to state 100


state 74

    (6) instruction -> FOR var = range . block
    (11) block -> . instructions
    (12) block -> . { instructions }
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . FOR var = range block
    (7) instruction -> . WHILE ( condition ) block
    (8) instruction -> . IF ( condition ) block ELSE block
    (9) instruction -> . IF ( condition ) block
    (10) instruction -> . statement ;
    (25) statement -> . PRINT print_args
    (26) statement -> . RETURN expr
    (27) statement -> . CONTINUE
    (28) statement -> . BREAK
    (29) statement -> . element assign_op expr
    (30) statement -> . var assign_op expr
    (41) element -> . matrix_element
    (42) element -> . vector_element
    (45) var -> . ID
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (43) vector_element -> . ID [ INTNUM ]
    {               shift and go to state 103
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 17

    var                            shift and go to state 6
    block                          shift and go to state 101
    instructions                   shift and go to state 102
    instruction                    shift and go to state 4
    statement                      shift and go to state 9
    element                        shift and go to state 14
    matrix_element                 shift and go to state 15
    vector_element                 shift and go to state 16

state 75

    (13) range -> num_expr . : num_expr
    :               shift and go to state 104


state 76

    (7) instruction -> WHILE ( condition ) . block
    (11) block -> . instructions
    (12) block -> . { instructions }
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . FOR var = range block
    (7) instruction -> . WHILE ( condition ) block
    (8) instruction -> . IF ( condition ) block ELSE block
    (9) instruction -> . IF ( condition ) block
    (10) instruction -> . statement ;
    (25) statement -> . PRINT print_args
    (26) statement -> . RETURN expr
    (27) statement -> . CONTINUE
    (28) statement -> . BREAK
    (29) statement -> . element assign_op expr
    (30) statement -> . var assign_op expr
    (41) element -> . matrix_element
    (42) element -> . vector_element
    (45) var -> . ID
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (43) vector_element -> . ID [ INTNUM ]
    {               shift and go to state 103
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 17

    block                          shift and go to state 105
    instructions                   shift and go to state 102
    instruction                    shift and go to state 4
    var                            shift and go to state 6
    statement                      shift and go to state 9
    element                        shift and go to state 14
    matrix_element                 shift and go to state 15
    vector_element                 shift and go to state 16

state 77

    (14) condition -> expr > . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 106
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 78

    (15) condition -> expr < . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 107
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 79

    (16) condition -> expr GREATER_EQUAL . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 108
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 80

    (17) condition -> expr LESS_EQUAL . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 109
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 81

    (18) condition -> expr NOT_EQUAL . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 110
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 82

    (19) condition -> expr EQUAL . expr
    (46) expr -> . expr '
    (47) expr -> . - expr
    (48) expr -> . STRING
    (49) expr -> . vector_element
    (50) expr -> . matrix_element
    (51) expr -> . matrix_function
    (52) expr -> . matrix
    (53) expr -> . num_expr
    (54) expr -> . expr DOTDIV expr
    (55) expr -> . expr DOTMUL expr
    (56) expr -> . expr DOTSUB expr
    (57) expr -> . expr DOTADD expr
    (58) expr -> . num_expr / num_expr
    (59) expr -> . num_expr * num_expr
    (60) expr -> . num_expr - num_expr
    (61) expr -> . num_expr + num_expr
    (43) vector_element -> . ID [ INTNUM ]
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (31) matrix_function -> . matrix_function_name ( INTNUM )
    (35) matrix -> . [ matrix_varargs ]
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (32) matrix_function_name -> . ZEROS
    (33) matrix_function_name -> . ONES
    (34) matrix_function_name -> . EYE
    (45) var -> . ID
    -               shift and go to state 32
    STRING          shift and go to state 33
    ID              shift and go to state 39
    [               shift and go to state 40
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    EYE             shift and go to state 47

    expr                           shift and go to state 111
    vector_element                 shift and go to state 34
    matrix_element                 shift and go to state 35
    matrix_function                shift and go to state 36
    matrix                         shift and go to state 37
    num_expr                       shift and go to state 38
    matrix_function_name           shift and go to state 42
    var                            shift and go to state 43

state 83

    (8) instruction -> IF ( condition ) . block ELSE block
    (9) instruction -> IF ( condition ) . block
    (11) block -> . instructions
    (12) block -> . { instructions }
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . FOR var = range block
    (7) instruction -> . WHILE ( condition ) block
    (8) instruction -> . IF ( condition ) block ELSE block
    (9) instruction -> . IF ( condition ) block
    (10) instruction -> . statement ;
    (25) statement -> . PRINT print_args
    (26) statement -> . RETURN expr
    (27) statement -> . CONTINUE
    (28) statement -> . BREAK
    (29) statement -> . element assign_op expr
    (30) statement -> . var assign_op expr
    (41) element -> . matrix_element
    (42) element -> . vector_element
    (45) var -> . ID
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (43) vector_element -> . ID [ INTNUM ]
    {               shift and go to state 103
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 17

    block                          shift and go to state 112
    instructions                   shift and go to state 102
    instruction                    shift and go to state 4
    var                            shift and go to state 6
    statement                      shift and go to state 9
    element                        shift and go to state 14
    matrix_element                 shift and go to state 15
    vector_element                 shift and go to state 16

state 84

    (66) print_args -> print_args , expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    ,               reduce using rule 66 (print_args -> print_args , expr .)
    ;               reduce using rule 66 (print_args -> print_args , expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 85

    (54) expr -> expr DOTDIV expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    DOTDIV          reduce using rule 54 (expr -> expr DOTDIV expr .)
    DOTMUL          reduce using rule 54 (expr -> expr DOTDIV expr .)
    DOTSUB          reduce using rule 54 (expr -> expr DOTDIV expr .)
    DOTADD          reduce using rule 54 (expr -> expr DOTDIV expr .)
    ,               reduce using rule 54 (expr -> expr DOTDIV expr .)
    ;               reduce using rule 54 (expr -> expr DOTDIV expr .)
    >               reduce using rule 54 (expr -> expr DOTDIV expr .)
    <               reduce using rule 54 (expr -> expr DOTDIV expr .)
    GREATER_EQUAL   reduce using rule 54 (expr -> expr DOTDIV expr .)
    LESS_EQUAL      reduce using rule 54 (expr -> expr DOTDIV expr .)
    NOT_EQUAL       reduce using rule 54 (expr -> expr DOTDIV expr .)
    EQUAL           reduce using rule 54 (expr -> expr DOTDIV expr .)
    )               reduce using rule 54 (expr -> expr DOTDIV expr .)
    '               shift and go to state 57


state 86

    (55) expr -> expr DOTMUL expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    DOTDIV          reduce using rule 55 (expr -> expr DOTMUL expr .)
    DOTMUL          reduce using rule 55 (expr -> expr DOTMUL expr .)
    DOTSUB          reduce using rule 55 (expr -> expr DOTMUL expr .)
    DOTADD          reduce using rule 55 (expr -> expr DOTMUL expr .)
    ,               reduce using rule 55 (expr -> expr DOTMUL expr .)
    ;               reduce using rule 55 (expr -> expr DOTMUL expr .)
    >               reduce using rule 55 (expr -> expr DOTMUL expr .)
    <               reduce using rule 55 (expr -> expr DOTMUL expr .)
    GREATER_EQUAL   reduce using rule 55 (expr -> expr DOTMUL expr .)
    LESS_EQUAL      reduce using rule 55 (expr -> expr DOTMUL expr .)
    NOT_EQUAL       reduce using rule 55 (expr -> expr DOTMUL expr .)
    EQUAL           reduce using rule 55 (expr -> expr DOTMUL expr .)
    )               reduce using rule 55 (expr -> expr DOTMUL expr .)
    '               shift and go to state 57


state 87

    (56) expr -> expr DOTSUB expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    DOTSUB          reduce using rule 56 (expr -> expr DOTSUB expr .)
    DOTADD          reduce using rule 56 (expr -> expr DOTSUB expr .)
    ,               reduce using rule 56 (expr -> expr DOTSUB expr .)
    ;               reduce using rule 56 (expr -> expr DOTSUB expr .)
    >               reduce using rule 56 (expr -> expr DOTSUB expr .)
    <               reduce using rule 56 (expr -> expr DOTSUB expr .)
    GREATER_EQUAL   reduce using rule 56 (expr -> expr DOTSUB expr .)
    LESS_EQUAL      reduce using rule 56 (expr -> expr DOTSUB expr .)
    NOT_EQUAL       reduce using rule 56 (expr -> expr DOTSUB expr .)
    EQUAL           reduce using rule 56 (expr -> expr DOTSUB expr .)
    )               reduce using rule 56 (expr -> expr DOTSUB expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59


state 88

    (57) expr -> expr DOTADD expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    DOTSUB          reduce using rule 57 (expr -> expr DOTADD expr .)
    DOTADD          reduce using rule 57 (expr -> expr DOTADD expr .)
    ,               reduce using rule 57 (expr -> expr DOTADD expr .)
    ;               reduce using rule 57 (expr -> expr DOTADD expr .)
    >               reduce using rule 57 (expr -> expr DOTADD expr .)
    <               reduce using rule 57 (expr -> expr DOTADD expr .)
    GREATER_EQUAL   reduce using rule 57 (expr -> expr DOTADD expr .)
    LESS_EQUAL      reduce using rule 57 (expr -> expr DOTADD expr .)
    NOT_EQUAL       reduce using rule 57 (expr -> expr DOTADD expr .)
    EQUAL           reduce using rule 57 (expr -> expr DOTADD expr .)
    )               reduce using rule 57 (expr -> expr DOTADD expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59


state 89

    (58) expr -> num_expr / num_expr .
    '               reduce using rule 58 (expr -> num_expr / num_expr .)
    DOTDIV          reduce using rule 58 (expr -> num_expr / num_expr .)
    DOTMUL          reduce using rule 58 (expr -> num_expr / num_expr .)
    DOTSUB          reduce using rule 58 (expr -> num_expr / num_expr .)
    DOTADD          reduce using rule 58 (expr -> num_expr / num_expr .)
    ,               reduce using rule 58 (expr -> num_expr / num_expr .)
    ;               reduce using rule 58 (expr -> num_expr / num_expr .)
    >               reduce using rule 58 (expr -> num_expr / num_expr .)
    <               reduce using rule 58 (expr -> num_expr / num_expr .)
    GREATER_EQUAL   reduce using rule 58 (expr -> num_expr / num_expr .)
    LESS_EQUAL      reduce using rule 58 (expr -> num_expr / num_expr .)
    NOT_EQUAL       reduce using rule 58 (expr -> num_expr / num_expr .)
    EQUAL           reduce using rule 58 (expr -> num_expr / num_expr .)
    )               reduce using rule 58 (expr -> num_expr / num_expr .)


state 90

    (59) expr -> num_expr * num_expr .
    '               reduce using rule 59 (expr -> num_expr * num_expr .)
    DOTDIV          reduce using rule 59 (expr -> num_expr * num_expr .)
    DOTMUL          reduce using rule 59 (expr -> num_expr * num_expr .)
    DOTSUB          reduce using rule 59 (expr -> num_expr * num_expr .)
    DOTADD          reduce using rule 59 (expr -> num_expr * num_expr .)
    ,               reduce using rule 59 (expr -> num_expr * num_expr .)
    ;               reduce using rule 59 (expr -> num_expr * num_expr .)
    >               reduce using rule 59 (expr -> num_expr * num_expr .)
    <               reduce using rule 59 (expr -> num_expr * num_expr .)
    GREATER_EQUAL   reduce using rule 59 (expr -> num_expr * num_expr .)
    LESS_EQUAL      reduce using rule 59 (expr -> num_expr * num_expr .)
    NOT_EQUAL       reduce using rule 59 (expr -> num_expr * num_expr .)
    EQUAL           reduce using rule 59 (expr -> num_expr * num_expr .)
    )               reduce using rule 59 (expr -> num_expr * num_expr .)


state 91

    (60) expr -> num_expr - num_expr .
    '               reduce using rule 60 (expr -> num_expr - num_expr .)
    DOTDIV          reduce using rule 60 (expr -> num_expr - num_expr .)
    DOTMUL          reduce using rule 60 (expr -> num_expr - num_expr .)
    DOTSUB          reduce using rule 60 (expr -> num_expr - num_expr .)
    DOTADD          reduce using rule 60 (expr -> num_expr - num_expr .)
    ,               reduce using rule 60 (expr -> num_expr - num_expr .)
    ;               reduce using rule 60 (expr -> num_expr - num_expr .)
    >               reduce using rule 60 (expr -> num_expr - num_expr .)
    <               reduce using rule 60 (expr -> num_expr - num_expr .)
    GREATER_EQUAL   reduce using rule 60 (expr -> num_expr - num_expr .)
    LESS_EQUAL      reduce using rule 60 (expr -> num_expr - num_expr .)
    NOT_EQUAL       reduce using rule 60 (expr -> num_expr - num_expr .)
    EQUAL           reduce using rule 60 (expr -> num_expr - num_expr .)
    )               reduce using rule 60 (expr -> num_expr - num_expr .)


state 92

    (61) expr -> num_expr + num_expr .
    '               reduce using rule 61 (expr -> num_expr + num_expr .)
    DOTDIV          reduce using rule 61 (expr -> num_expr + num_expr .)
    DOTMUL          reduce using rule 61 (expr -> num_expr + num_expr .)
    DOTSUB          reduce using rule 61 (expr -> num_expr + num_expr .)
    DOTADD          reduce using rule 61 (expr -> num_expr + num_expr .)
    ,               reduce using rule 61 (expr -> num_expr + num_expr .)
    ;               reduce using rule 61 (expr -> num_expr + num_expr .)
    >               reduce using rule 61 (expr -> num_expr + num_expr .)
    <               reduce using rule 61 (expr -> num_expr + num_expr .)
    GREATER_EQUAL   reduce using rule 61 (expr -> num_expr + num_expr .)
    LESS_EQUAL      reduce using rule 61 (expr -> num_expr + num_expr .)
    NOT_EQUAL       reduce using rule 61 (expr -> num_expr + num_expr .)
    EQUAL           reduce using rule 61 (expr -> num_expr + num_expr .)
    )               reduce using rule 61 (expr -> num_expr + num_expr .)


state 93

    (43) vector_element -> ID [ INTNUM . ]
    (44) matrix_element -> ID [ INTNUM . , INTNUM ]
    ]               shift and go to state 100
    ,               shift and go to state 99


state 94

    (38) vector -> [ vector_varargs . ]
    (40) vector_varargs -> vector_varargs . , INTNUM
    ]               shift and go to state 113
    ,               shift and go to state 114


state 95

    (39) vector_varargs -> INTNUM .
    ]               reduce using rule 39 (vector_varargs -> INTNUM .)
    ,               reduce using rule 39 (vector_varargs -> INTNUM .)


state 96

    (35) matrix -> [ matrix_varargs ] .
    '               reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    DOTDIV          reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    DOTMUL          reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    DOTSUB          reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    DOTADD          reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    ,               reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    ;               reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    >               reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    <               reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    GREATER_EQUAL   reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    LESS_EQUAL      reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    NOT_EQUAL       reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    EQUAL           reduce using rule 35 (matrix -> [ matrix_varargs ] .)
    )               reduce using rule 35 (matrix -> [ matrix_varargs ] .)


state 97

    (37) matrix_varargs -> matrix_varargs , . vector
    (38) vector -> . [ vector_varargs ]
    [               shift and go to state 68

    vector                         shift and go to state 115

state 98

    (31) matrix_function -> matrix_function_name ( INTNUM . )
    )               shift and go to state 116


state 99

    (44) matrix_element -> ID [ INTNUM , . INTNUM ]
    INTNUM          shift and go to state 117


state 100

    (43) vector_element -> ID [ INTNUM ] .
    =               reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    ADDASSIGN       reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    SUBASSIGN       reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    DIVASSIGN       reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    MULASSIGN       reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    '               reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    DOTDIV          reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    DOTMUL          reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    DOTSUB          reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    DOTADD          reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    ,               reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    ;               reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    >               reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    <               reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    GREATER_EQUAL   reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    LESS_EQUAL      reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    NOT_EQUAL       reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    EQUAL           reduce using rule 43 (vector_element -> ID [ INTNUM ] .)
    )               reduce using rule 43 (vector_element -> ID [ INTNUM ] .)


state 101

    (6) instruction -> FOR var = range block .
    FOR             reduce using rule 6 (instruction -> FOR var = range block .)
    WHILE           reduce using rule 6 (instruction -> FOR var = range block .)
    IF              reduce using rule 6 (instruction -> FOR var = range block .)
    PRINT           reduce using rule 6 (instruction -> FOR var = range block .)
    RETURN          reduce using rule 6 (instruction -> FOR var = range block .)
    CONTINUE        reduce using rule 6 (instruction -> FOR var = range block .)
    BREAK           reduce using rule 6 (instruction -> FOR var = range block .)
    ID              reduce using rule 6 (instruction -> FOR var = range block .)
    $end            reduce using rule 6 (instruction -> FOR var = range block .)
    ELSE            reduce using rule 6 (instruction -> FOR var = range block .)
    }               reduce using rule 6 (instruction -> FOR var = range block .)


state 102

    (11) block -> instructions .
    $end            reduce using rule 11 (block -> instructions .)
    FOR             reduce using rule 11 (block -> instructions .)
    WHILE           reduce using rule 11 (block -> instructions .)
    IF              reduce using rule 11 (block -> instructions .)
    PRINT           reduce using rule 11 (block -> instructions .)
    RETURN          reduce using rule 11 (block -> instructions .)
    CONTINUE        reduce using rule 11 (block -> instructions .)
    BREAK           reduce using rule 11 (block -> instructions .)
    ID              reduce using rule 11 (block -> instructions .)
    ELSE            reduce using rule 11 (block -> instructions .)
    }               reduce using rule 11 (block -> instructions .)


state 103

    (12) block -> { . instructions }
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . FOR var = range block
    (7) instruction -> . WHILE ( condition ) block
    (8) instruction -> . IF ( condition ) block ELSE block
    (9) instruction -> . IF ( condition ) block
    (10) instruction -> . statement ;
    (25) statement -> . PRINT print_args
    (26) statement -> . RETURN expr
    (27) statement -> . CONTINUE
    (28) statement -> . BREAK
    (29) statement -> . element assign_op expr
    (30) statement -> . var assign_op expr
    (41) element -> . matrix_element
    (42) element -> . vector_element
    (45) var -> . ID
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (43) vector_element -> . ID [ INTNUM ]
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 17

    instructions                   shift and go to state 118
    instruction                    shift and go to state 4
    var                            shift and go to state 6
    statement                      shift and go to state 9
    element                        shift and go to state 14
    matrix_element                 shift and go to state 15
    vector_element                 shift and go to state 16

state 104

    (13) range -> num_expr : . num_expr
    (62) num_expr -> . var
    (63) num_expr -> . FLOAT
    (64) num_expr -> . INTNUM
    (45) var -> . ID
    FLOAT           shift and go to state 44
    INTNUM          shift and go to state 41
    ID              shift and go to state 20

    num_expr                       shift and go to state 119
    var                            shift and go to state 43

state 105

    (7) instruction -> WHILE ( condition ) block .
    FOR             reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    WHILE           reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    IF              reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    PRINT           reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    RETURN          reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    CONTINUE        reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    BREAK           reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    ID              reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    $end            reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    ELSE            reduce using rule 7 (instruction -> WHILE ( condition ) block .)
    }               reduce using rule 7 (instruction -> WHILE ( condition ) block .)


state 106

    (14) condition -> expr > expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    )               reduce using rule 14 (condition -> expr > expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 107

    (15) condition -> expr < expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    )               reduce using rule 15 (condition -> expr < expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 108

    (16) condition -> expr GREATER_EQUAL expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    )               reduce using rule 16 (condition -> expr GREATER_EQUAL expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 109

    (17) condition -> expr LESS_EQUAL expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    )               reduce using rule 17 (condition -> expr LESS_EQUAL expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 110

    (18) condition -> expr NOT_EQUAL expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    )               reduce using rule 18 (condition -> expr NOT_EQUAL expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 111

    (19) condition -> expr EQUAL expr .
    (46) expr -> expr . '
    (54) expr -> expr . DOTDIV expr
    (55) expr -> expr . DOTMUL expr
    (56) expr -> expr . DOTSUB expr
    (57) expr -> expr . DOTADD expr
    )               reduce using rule 19 (condition -> expr EQUAL expr .)
    '               shift and go to state 57
    DOTDIV          shift and go to state 58
    DOTMUL          shift and go to state 59
    DOTSUB          shift and go to state 60
    DOTADD          shift and go to state 61


state 112

    (8) instruction -> IF ( condition ) block . ELSE block
    (9) instruction -> IF ( condition ) block .
    ELSE            shift and go to state 120
    FOR             reduce using rule 9 (instruction -> IF ( condition ) block .)
    WHILE           reduce using rule 9 (instruction -> IF ( condition ) block .)
    IF              reduce using rule 9 (instruction -> IF ( condition ) block .)
    PRINT           reduce using rule 9 (instruction -> IF ( condition ) block .)
    RETURN          reduce using rule 9 (instruction -> IF ( condition ) block .)
    CONTINUE        reduce using rule 9 (instruction -> IF ( condition ) block .)
    BREAK           reduce using rule 9 (instruction -> IF ( condition ) block .)
    ID              reduce using rule 9 (instruction -> IF ( condition ) block .)
    $end            reduce using rule 9 (instruction -> IF ( condition ) block .)
    }               reduce using rule 9 (instruction -> IF ( condition ) block .)


state 113

    (38) vector -> [ vector_varargs ] .
    ]               reduce using rule 38 (vector -> [ vector_varargs ] .)
    ,               reduce using rule 38 (vector -> [ vector_varargs ] .)


state 114

    (40) vector_varargs -> vector_varargs , . INTNUM
    INTNUM          shift and go to state 121


state 115

    (37) matrix_varargs -> matrix_varargs , vector .
    ]               reduce using rule 37 (matrix_varargs -> matrix_varargs , vector .)
    ,               reduce using rule 37 (matrix_varargs -> matrix_varargs , vector .)


state 116

    (31) matrix_function -> matrix_function_name ( INTNUM ) .
    '               reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    DOTDIV          reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    DOTMUL          reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    DOTSUB          reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    DOTADD          reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    ,               reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    ;               reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    >               reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    <               reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    GREATER_EQUAL   reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    LESS_EQUAL      reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    NOT_EQUAL       reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    EQUAL           reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)
    )               reduce using rule 31 (matrix_function -> matrix_function_name ( INTNUM ) .)


state 117

    (44) matrix_element -> ID [ INTNUM , INTNUM . ]
    ]               shift and go to state 122


state 118

    (12) block -> { instructions . }
    }               shift and go to state 123


state 119

    (13) range -> num_expr : num_expr .
    {               reduce using rule 13 (range -> num_expr : num_expr .)
    FOR             reduce using rule 13 (range -> num_expr : num_expr .)
    WHILE           reduce using rule 13 (range -> num_expr : num_expr .)
    IF              reduce using rule 13 (range -> num_expr : num_expr .)
    PRINT           reduce using rule 13 (range -> num_expr : num_expr .)
    RETURN          reduce using rule 13 (range -> num_expr : num_expr .)
    CONTINUE        reduce using rule 13 (range -> num_expr : num_expr .)
    BREAK           reduce using rule 13 (range -> num_expr : num_expr .)
    ID              reduce using rule 13 (range -> num_expr : num_expr .)


state 120

    (8) instruction -> IF ( condition ) block ELSE . block
    (11) block -> . instructions
    (12) block -> . { instructions }
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . FOR var = range block
    (7) instruction -> . WHILE ( condition ) block
    (8) instruction -> . IF ( condition ) block ELSE block
    (9) instruction -> . IF ( condition ) block
    (10) instruction -> . statement ;
    (25) statement -> . PRINT print_args
    (26) statement -> . RETURN expr
    (27) statement -> . CONTINUE
    (28) statement -> . BREAK
    (29) statement -> . element assign_op expr
    (30) statement -> . var assign_op expr
    (41) element -> . matrix_element
    (42) element -> . vector_element
    (45) var -> . ID
    (44) matrix_element -> . ID [ INTNUM , INTNUM ]
    (43) vector_element -> . ID [ INTNUM ]
    {               shift and go to state 103
    FOR             shift and go to state 5
    WHILE           shift and go to state 7
    IF              shift and go to state 8
    PRINT           shift and go to state 10
    RETURN          shift and go to state 11
    CONTINUE        shift and go to state 12
    BREAK           shift and go to state 13
    ID              shift and go to state 17

    block                          shift and go to state 124
    instructions                   shift and go to state 102
    instruction                    shift and go to state 4
    var                            shift and go to state 6
    statement                      shift and go to state 9
    element                        shift and go to state 14
    matrix_element                 shift and go to state 15
    vector_element                 shift and go to state 16

state 121

    (40) vector_varargs -> vector_varargs , INTNUM .
    ]               reduce using rule 40 (vector_varargs -> vector_varargs , INTNUM .)
    ,               reduce using rule 40 (vector_varargs -> vector_varargs , INTNUM .)


state 122

    (44) matrix_element -> ID [ INTNUM , INTNUM ] .
    =               reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    ADDASSIGN       reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    SUBASSIGN       reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    DIVASSIGN       reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    MULASSIGN       reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    '               reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    DOTDIV          reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    DOTMUL          reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    DOTSUB          reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    DOTADD          reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    ,               reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    ;               reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    >               reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    <               reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    GREATER_EQUAL   reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    LESS_EQUAL      reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    NOT_EQUAL       reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    EQUAL           reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)
    )               reduce using rule 44 (matrix_element -> ID [ INTNUM , INTNUM ] .)


state 123

    (12) block -> { instructions } .
    $end            reduce using rule 12 (block -> { instructions } .)
    FOR             reduce using rule 12 (block -> { instructions } .)
    WHILE           reduce using rule 12 (block -> { instructions } .)
    IF              reduce using rule 12 (block -> { instructions } .)
    PRINT           reduce using rule 12 (block -> { instructions } .)
    RETURN          reduce using rule 12 (block -> { instructions } .)
    CONTINUE        reduce using rule 12 (block -> { instructions } .)
    BREAK           reduce using rule 12 (block -> { instructions } .)
    ID              reduce using rule 12 (block -> { instructions } .)
    ELSE            reduce using rule 12 (block -> { instructions } .)
    }               reduce using rule 12 (block -> { instructions } .)


state 124

    (8) instruction -> IF ( condition ) block ELSE block .
    FOR             reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    WHILE           reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    IF              reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    PRINT           reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    RETURN          reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    CONTINUE        reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    BREAK           reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    ID              reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    $end            reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    ELSE            reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)
    }               reduce using rule 8 (instruction -> IF ( condition ) block ELSE block .)


Conflicts:

shift/reduce conflict for FOR in state 4 resolved as shift
shift/reduce conflict for WHILE in state 4 resolved as shift
shift/reduce conflict for IF in state 4 resolved as shift
shift/reduce conflict for PRINT in state 4 resolved as shift
shift/reduce conflict for RETURN in state 4 resolved as shift
shift/reduce conflict for CONTINUE in state 4 resolved as shift
shift/reduce conflict for BREAK in state 4 resolved as shift
shift/reduce conflict for ID in state 4 resolved as shift